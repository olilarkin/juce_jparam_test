/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

JparamTestAudioProcessor::JparamTestAudioProcessor()
{
  for (auto i = 0; i < kNumParams; i++)
  {
    JParam* param = new JParam();
    
    switch (i)
    {
      case kParamGain:
        param->InitFloat("Gain", 0., -70., 12., 0.1, "dB");
        param->SignDisplay();
        break;
      case kParamType:
        param->InitEnum("Type", 0, 3);
        param->SetDisplayText(0, "One");
        param->SetDisplayText(1, "Two");
        param->SetDisplayText(2, "Three");
        break;
      case kParamDelayTime:
      {
        auto displayTextFunction = [](float val)->String
        {
          String str;
          
          if (val < 1.)
          {
            val *= 1000.;
            str = String::formatted("%2.0f", val);
            str.append(" ms", 3);
          }
          else
          {
            str = String::formatted("%2.1f", val);
            str.append(" s", 2);
          }
          
          return str;
        };
        
        param->InitFloat("DelayTime", 10., 0.1, 10., 0.01, "", "", false, 1., displayTextFunction);
        break;
      }
      default:
        break;
    }
    
    addParameter(param);
  }
}

JparamTestAudioProcessor::~JparamTestAudioProcessor()
{
}

const String JparamTestAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

bool JparamTestAudioProcessor::acceptsMidi() const
{
  #if JucePlugin_WantsMidiInput
  return true;
  #else
  return false;
  #endif
}

bool JparamTestAudioProcessor::producesMidi() const
{
  #if JucePlugin_ProducesMidiOutput
  return true;
  #else
  return false;
  #endif
}

bool JparamTestAudioProcessor::silenceInProducesSilenceOut() const
{
  return false;
}

double JparamTestAudioProcessor::getTailLengthSeconds() const
{
  return 0.0;
}

int JparamTestAudioProcessor::getNumPrograms()
{
  return 1;
}

int JparamTestAudioProcessor::getCurrentProgram()
{
  return 0;
}

void JparamTestAudioProcessor::setCurrentProgram (int index)
{
}

const String JparamTestAudioProcessor::getProgramName (int index)
{
  return String();
}

void JparamTestAudioProcessor::changeProgramName (int index, const String& newName)
{
}

void JparamTestAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
}

void JparamTestAudioProcessor::releaseResources()
{
}

void JparamTestAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
  const int totalNumInputChannels  = getTotalNumInputChannels();
  const int totalNumOutputChannels = getTotalNumOutputChannels();

  float gain = dynamic_cast<JParam*>(getParameters()[kParamGain])->GetDBToAmp();

  for (int i = totalNumInputChannels; i < totalNumOutputChannels; ++i)
    buffer.clear (i, 0, buffer.getNumSamples());

  for (int channel = 0; channel < totalNumInputChannels; ++channel)
  {
    float* channelData = buffer.getWritePointer (channel);
  
    for (int s = 0; s < buffer.getNumSamples(); s++)
    {
      channelData[s] = channelData[s] * gain;
    }
  }
}

bool JparamTestAudioProcessor::hasEditor() const
{
  return false;
}

AudioProcessorEditor* JparamTestAudioProcessor::createEditor()
{
  return nullptr;//new JparamTestAudioProcessorEditor (*this);
}

void JparamTestAudioProcessor::getStateInformation (MemoryBlock& destData)
{
}

void JparamTestAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
}

AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
  return new JparamTestAudioProcessor();
}
